## Javascript垃圾回收机制

### 引用计数（现代浏览器已经不常用，老版IE会使用)
当保存在内存里所有对象引用次数为0，则释放内存，通俗点就是如果没有对象引用这个对象，那么这个对象将会被回收

**循环引用问题**: 如果两个对象互相引用，尽管已不再使用，但是垃圾回收器不会进行回收，造成内存泄漏，例如

``` javascript
var div = document.createElement("div");
div.onclick = function() {
    console.log(this);
}
```

### 标记-清除
假定设置一个根root对象（浏览器中window对象），定期从根开始，找所有从根引用等对象，然后找这些对象引用的对象，对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象

**内存碎片问题**:

---

### 内存泄漏

- **循环引用**
- **无意的全局变量**
- **被遗忘的计时器和回调函数**
- **闭包**

### 从内存比较null与undefined的区别

- **全局变量为null，变量的指针对象及值清空**
- **对象属性为null，给这个属性分配一块空内存，值为null**
- **全局变量为undefined，变量的值清空，但变量依旧在**
- **对象属性为undefined，值为空值**

### 思考：const实际上是变量指向的那个内存地址所保存的数据不得改动，对于基本数据类型，值就保存在变量指向的那个内存地址，因此等同于常量。对于复合类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针。
  
